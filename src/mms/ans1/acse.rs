// This file was generated by the asn1-compiler tool.
// *DO NOT EDIT THIS FILE MANUALLY*.
// The asn1-compiler tool is used to compile the ASN.1 files into Rust modules
// using the rasn-compiler crate.
// The asn1-compiler tool is located in the src/mms/ans1/asn1-compiler.rs file.
// For running the asn1-compiler tool, run the following command:
// `cargo run --bin asn1-compiler`

#[allow(
	missing_docs,
	clippy::must_use_candidate,
	clippy::missing_const_for_fn,
	clippy::missing_docs_in_private_items,
	clippy::unseparated_literal_suffix
)]
#[allow(
	non_camel_case_types,
	non_snake_case,
	non_upper_case_globals,
	unused,
	clippy::too_many_arguments
)]
pub mod acse_1 {
	extern crate alloc;
	use core::borrow::Borrow;
	use std::sync::LazyLock;

	use rasn::prelude::*;
	#[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
	#[rasn(tag(application, 1), identifier = "AARE-apdu")]
	pub struct AAREApdu {
		#[rasn(
			tag(context, 0),
			default = "aareapdu_protocol_version_default",
			identifier = "protocol-version"
		)]
		pub protocol_version: BitString,
		#[rasn(tag(explicit(context, 1)), identifier = "application-context-name")]
		pub application_context_name: ObjectIdentifier,
		#[rasn(tag(explicit(context, 2)))]
		pub result: AssociateResult,
		#[rasn(tag(explicit(context, 3)), identifier = "result-source-diagnostic")]
		pub result_source_diagnostic: AssociateSourceDiagnostic,
		#[rasn(tag(explicit(context, 4)), identifier = "responding-AP-title")]
		pub responding_ap_title: Option<APTitle>,
		#[rasn(tag(explicit(context, 5)), identifier = "responding-AE-qualifier")]
		pub responding_ae_qualifier: Option<AEQualifier>,
		#[rasn(tag(explicit(context, 6)), identifier = "responding-AP-invocation-identifier")]
		pub responding_ap_invocation_identifier: Option<APInvocationIdentifier>,
		#[rasn(tag(explicit(context, 7)), identifier = "responding-AE-invocation-identifier")]
		pub responding_ae_invocation_identifier: Option<AEInvocationIdentifier>,
		#[rasn(tag(context, 8), identifier = "responder-acse-requirements")]
		pub responder_acse_requirements: Option<ACSERequirements>,
		#[rasn(tag(context, 9), identifier = "mechanism-name")]
		pub mechanism_name: Option<MechanismName>,
		#[rasn(tag(explicit(context, 10)), identifier = "responding-authentication-value")]
		pub responding_authentication_value: Option<AuthenticationValue>,
		#[rasn(tag(context, 11), identifier = "aSO-context-name-list")]
		pub a_so_context_name_list: Option<ASOContextNameList>,
		#[rasn(tag(context, 29), identifier = "implementation-information")]
		pub implementation_information: Option<ImplementationData>,
		#[rasn(tag(context, 30), identifier = "user-information")]
		pub user_information: Option<AssociationData>,
	}
	impl AAREApdu {
		pub fn new(
			protocol_version: BitString,
			application_context_name: ObjectIdentifier,
			result: AssociateResult,
			result_source_diagnostic: AssociateSourceDiagnostic,
			responding_ap_title: Option<APTitle>,
			responding_ae_qualifier: Option<AEQualifier>,
			responding_ap_invocation_identifier: Option<APInvocationIdentifier>,
			responding_ae_invocation_identifier: Option<AEInvocationIdentifier>,
			responder_acse_requirements: Option<ACSERequirements>,
			mechanism_name: Option<MechanismName>,
			responding_authentication_value: Option<AuthenticationValue>,
			a_so_context_name_list: Option<ASOContextNameList>,
			implementation_information: Option<ImplementationData>,
			user_information: Option<AssociationData>,
		) -> Self {
			Self {
				protocol_version,
				application_context_name,
				result,
				result_source_diagnostic,
				responding_ap_title,
				responding_ae_qualifier,
				responding_ap_invocation_identifier,
				responding_ae_invocation_identifier,
				responder_acse_requirements,
				mechanism_name,
				responding_authentication_value,
				a_so_context_name_list,
				implementation_information,
				user_information,
			}
		}
	}
	fn aareapdu_protocol_version_default() -> BitString {
		[true].into_iter().collect()
	}
	#[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
	#[rasn(tag(application, 0), identifier = "AARQ-apdu")]
	pub struct AARQApdu {
		#[rasn(tag(context, 0), identifier = "protocol-version")]
		pub protocol_version: Option<BitString>,
		#[rasn(tag(explicit(context, 1)), identifier = "application-context-name")]
		pub application_context_name: ObjectIdentifier,
		#[rasn(tag(explicit(context, 2)), identifier = "called-AP-title")]
		pub called_ap_title: Option<APTitle>,
		#[rasn(tag(explicit(context, 3)), identifier = "called-AE-qualifier")]
		pub called_ae_qualifier: Option<AEQualifier>,
		#[rasn(tag(explicit(context, 4)), identifier = "called-AP-invocation-identifier")]
		pub called_ap_invocation_identifier: Option<APInvocationIdentifier>,
		#[rasn(tag(explicit(context, 5)), identifier = "called-AE-invocation-identifier")]
		pub called_ae_invocation_identifier: Option<AEInvocationIdentifier>,
		#[rasn(tag(explicit(context, 6)), identifier = "calling-AP-title")]
		pub calling_ap_title: Option<APTitle>,
		#[rasn(tag(explicit(context, 7)), identifier = "calling-AE-qualifier")]
		pub calling_ae_qualifier: Option<AEQualifier>,
		#[rasn(tag(explicit(context, 8)), identifier = "calling-AP-invocation-identifier")]
		pub calling_ap_invocation_identifier: Option<APInvocationIdentifier>,
		#[rasn(tag(explicit(context, 9)), identifier = "calling-AE-invocation-identifier")]
		pub calling_ae_invocation_identifier: Option<AEInvocationIdentifier>,
		#[rasn(tag(context, 10), identifier = "sender-acse-requirements")]
		pub sender_acse_requirements: Option<ACSERequirements>,
		#[rasn(tag(context, 11), identifier = "mechanism-name")]
		pub mechanism_name: Option<MechanismName>,
		#[rasn(tag(explicit(context, 12)), identifier = "calling-authentication-value")]
		pub calling_authentication_value: Option<AuthenticationValue>,
		#[rasn(tag(context, 13), identifier = "aSO-context-name-list")]
		pub a_so_context_name_list: Option<ASOContextNameList>,
		#[rasn(tag(context, 29), identifier = "implementation-information")]
		pub implementation_information: Option<ImplementationData>,
		#[rasn(tag(context, 30), identifier = "user-information")]
		pub user_information: Option<AssociationData>,
	}
	impl AARQApdu {
		pub fn new(
			protocol_version: Option<BitString>,
			application_context_name: ObjectIdentifier,
			called_ap_title: Option<APTitle>,
			called_ae_qualifier: Option<AEQualifier>,
			called_ap_invocation_identifier: Option<APInvocationIdentifier>,
			called_ae_invocation_identifier: Option<AEInvocationIdentifier>,
			calling_ap_title: Option<APTitle>,
			calling_ae_qualifier: Option<AEQualifier>,
			calling_ap_invocation_identifier: Option<APInvocationIdentifier>,
			calling_ae_invocation_identifier: Option<AEInvocationIdentifier>,
			sender_acse_requirements: Option<ACSERequirements>,
			mechanism_name: Option<MechanismName>,
			calling_authentication_value: Option<AuthenticationValue>,
			a_so_context_name_list: Option<ASOContextNameList>,
			implementation_information: Option<ImplementationData>,
			user_information: Option<AssociationData>,
		) -> Self {
			Self {
				protocol_version,
				application_context_name,
				called_ap_title,
				called_ae_qualifier,
				called_ap_invocation_identifier,
				called_ae_invocation_identifier,
				calling_ap_title,
				calling_ae_qualifier,
				calling_ap_invocation_identifier,
				calling_ae_invocation_identifier,
				sender_acse_requirements,
				mechanism_name,
				calling_authentication_value,
				a_so_context_name_list,
				implementation_information,
				user_information,
			}
		}
	}
	#[doc = "  may be used to identify the Association Control ASE."]
	#[doc = "  top level CHOICE"]
	#[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
	#[rasn(choice, identifier = "ACSE-apdu")]
	pub enum ACSEApdu {
		#[rasn(tag(application, 0))]
		aarq(AARQApdu),
		#[rasn(tag(application, 1))]
		aare(AAREApdu),
		#[rasn(tag(application, 2))]
		rlrq(RLRQApdu),
		#[rasn(tag(application, 3))]
		rlre(RLREApdu),
	}
	impl From<AARQApdu> for ACSEApdu {
		fn from(value: AARQApdu) -> Self {
			Self::aarq(value)
		}
	}
	impl From<AAREApdu> for ACSEApdu {
		fn from(value: AAREApdu) -> Self {
			Self::aare(value)
		}
	}
	impl From<RLRQApdu> for ACSEApdu {
		fn from(value: RLRQApdu) -> Self {
			Self::rlrq(value)
		}
	}
	impl From<RLREApdu> for ACSEApdu {
		fn from(value: RLREApdu) -> Self {
			Self::rlre(value)
		}
	}
	#[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
	#[rasn(delegate, identifier = "ACSE-requirements")]
	pub struct ACSERequirements(pub BitString);
	#[doc = "  A discussion of forming an AE-title-form2 from AP-title-form2 and AE-qualifier-form2 may be found in"]
	#[doc = "  itu-t Rec. X.665 | ISO/IEC 9834-6."]
	#[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
	#[rasn(delegate, identifier = "AE-invocation-identifier")]
	pub struct AEInvocationIdentifier(pub Integer);
	#[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
	#[rasn(delegate, identifier = "AE-qualifier")]
	pub struct AEQualifier(pub ASOQualifier);
	#[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
	#[rasn(choice, identifier = "AE-title")]
	pub enum AETitle {
		#[rasn(identifier = "ae-title-form2")]
		ae_title_form2(AETitleForm2),
	}
	impl From<AETitleForm2> for AETitle {
		fn from(value: AETitleForm2) -> Self {
			Self::ae_title_form2(value)
		}
	}
	#[doc = "  For access to The Directory (see ITU-T Rec. X.500 series | ISO/IEC 9594), an AE title has AE-title-form1. This value"]
	#[doc = "  can be constructed from AP-title-form1 and AE-qualifier-form1 values contained in an AARQ or AARE APDU."]
	#[doc = "  A discussion of forming an AE-title-form1 from AP-title-form1 and AE-qualifier form1 may be found in itu-t"]
	#[doc = "  Rec X.665 | ISO/IEC 9834-6."]
	#[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
	#[rasn(delegate, identifier = "AE-title-form2")]
	pub struct AETitleForm2(pub ObjectIdentifier);
	#[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
	#[rasn(delegate, identifier = "AP-invocation-identifier")]
	pub struct APInvocationIdentifier(pub Integer);
	#[doc = "  Application-entity title productions follow (not in alphabetical order)."]
	#[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
	#[rasn(choice, identifier = "AP-title")]
	pub enum APTitle {
		#[rasn(identifier = "ap-title-form2")]
		ap_title_form2(APTitleForm2),
	}
	impl From<APTitleForm2> for APTitle {
		fn from(value: APTitleForm2) -> Self {
			Self::ap_title_form2(value)
		}
	}
	#[doc = "  The value assigned to AE-qualifier-form1 is the relative distinguished name of a particular"]
	#[doc = "  application-entity of the application-process identified by AP-title-form1."]
	#[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
	#[rasn(delegate, identifier = "AP-title-form2")]
	pub struct APTitleForm2(pub ObjectIdentifier);
	#[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
	#[rasn(delegate, identifier = "ASO-context-name")]
	pub struct ASOContextName(pub ObjectIdentifier);
	#[doc = "  End of Application-entity title productions"]
	#[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
	#[rasn(delegate, identifier = "ASO-context-name-list")]
	pub struct ASOContextNameList(pub SequenceOf<ASOContextName>);
	#[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
	#[rasn(choice, identifier = "ASO-qualifier")]
	pub enum ASOQualifier {
		#[rasn(identifier = "aso-qualifier-form2")]
		aso_qualifier_form2(ASOQualifierForm2),
	}
	impl From<ASOQualifierForm2> for ASOQualifier {
		fn from(value: ASOQualifierForm2) -> Self {
			Self::aso_qualifier_form2(value)
		}
	}
	#[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
	#[rasn(delegate, identifier = "ASO-qualifier-form2")]
	pub struct ASOQualifierForm2(pub Integer);
	#[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
	#[rasn(delegate, identifier = "Associate-result", value("0..=2", extensible))]
	pub struct AssociateResult(pub Integer);
	#[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
	#[rasn(choice, identifier = "Associate-source-diagnostic")]
	pub enum AssociateSourceDiagnostic {
		#[rasn(value("0..=14", extensible), tag(context, 1), identifier = "service-user")]
		service_user(Integer),
		#[rasn(value("0..=2", extensible), tag(context, 2), identifier = "service-provider")]
		service_provider(Integer),
	}
	#[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
	#[rasn(delegate, identifier = "Association-data")]
	pub struct AssociationData(pub SequenceOf<Myexternal>);
	#[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
	#[rasn(choice, identifier = "Authentication-value")]
	pub enum AuthenticationValue {
		#[rasn(tag(context, 0))]
		charstring(GraphicString),
		#[rasn(tag(context, 1))]
		bitstring(BitString),
		#[rasn(tag(context, 2))]
		external(Myexternal2),
	}
	impl From<GraphicString> for AuthenticationValue {
		fn from(value: GraphicString) -> Self {
			Self::charstring(value)
		}
	}
	impl From<BitString> for AuthenticationValue {
		fn from(value: BitString) -> Self {
			Self::bitstring(value)
		}
	}
	impl From<Myexternal2> for AuthenticationValue {
		fn from(value: Myexternal2) -> Self {
			Self::external(value)
		}
	}
	#[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
	#[rasn(identifier = "Authentication-value-other")]
	pub struct AuthenticationValueOther {
		#[rasn(identifier = "other-mechanism-name")]
		pub other_mechanism_name: ObjectIdentifier,
		#[rasn(identifier = "other-mechanism-value")]
		pub other_mechanism_value: Any,
	}
	impl AuthenticationValueOther {
		pub fn new(other_mechanism_name: ObjectIdentifier, other_mechanism_value: Any) -> Self {
			Self { other_mechanism_name, other_mechanism_value }
		}
	}
	#[doc = "  The abstract syntax of (calling/responding) authentication-value is determined by the authentication mechanism used"]
	#[doc = "  during association establishment. The authentication mechanism is either explicitly denoted by the &id field (of type"]
	#[doc = "  OBJECT IDENTIFIER) for a mechanism belonging to the class MECHANISM-NAME, or it is known implicitly by"]
	#[doc = "  prior agreement between the communicating partners. If the \"other\" component is chosen, then the"]
	#[doc = "  \"mechanism-name\" component must be present in accordance with ITU-T Rec. X.680 | ISO/IEC 8824-1. If the value"]
	#[doc = "  \"mechanism-name\" occurs in the AARQ-apdu or the AARE-apdu, then that value must be the same as the value for"]
	#[doc = "  \"other-mechanism-name\"."]
	#[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
	#[rasn(delegate, identifier = "Implementation-data")]
	pub struct ImplementationData(pub GraphicString);
	#[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
	#[rasn(delegate, identifier = "Mechanism-name")]
	pub struct MechanismName(pub ObjectIdentifier);
	#[doc = " Inner type "]
	#[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
	#[rasn(choice)]
	pub enum MyexternalEncoding {
		#[rasn(tag(context, 0), identifier = "single-ASN1-type")]
		single_ASN1_type(Any),
		#[rasn(tag(context, 1), identifier = "octet-aligned")]
		octet_aligned(OctetString),
		#[rasn(tag(context, 2))]
		arbitrary(BitString),
	}
	impl From<Any> for MyexternalEncoding {
		fn from(value: Any) -> Self {
			Self::single_ASN1_type(value)
		}
	}
	impl From<OctetString> for MyexternalEncoding {
		fn from(value: OctetString) -> Self {
			Self::octet_aligned(value)
		}
	}
	impl From<BitString> for MyexternalEncoding {
		fn from(value: BitString) -> Self {
			Self::arbitrary(value)
		}
	}
	#[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
	#[rasn(tag(universal, 8))]
	pub struct Myexternal {
		#[rasn(identifier = "direct-reference")]
		pub direct_reference: Option<ObjectIdentifier>,
		#[rasn(identifier = "indirect-reference")]
		pub indirect_reference: Option<Integer>,
		pub encoding: MyexternalEncoding,
	}
	impl Myexternal {
		pub fn new(
			direct_reference: Option<ObjectIdentifier>,
			indirect_reference: Option<Integer>,
			encoding: MyexternalEncoding,
		) -> Self {
			Self { direct_reference, indirect_reference, encoding }
		}
	}
	#[doc = " Inner type "]
	#[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
	#[rasn(choice)]
	pub enum Myexternal2Encoding {
		#[rasn(tag(context, 0), identifier = "single-ASN1-type")]
		single_ASN1_type(Any),
		#[rasn(tag(context, 1), identifier = "octet-aligned")]
		octet_aligned(OctetString),
		#[rasn(tag(context, 2))]
		arbitrary(BitString),
	}
	impl From<Any> for Myexternal2Encoding {
		fn from(value: Any) -> Self {
			Self::single_ASN1_type(value)
		}
	}
	impl From<OctetString> for Myexternal2Encoding {
		fn from(value: OctetString) -> Self {
			Self::octet_aligned(value)
		}
	}
	impl From<BitString> for Myexternal2Encoding {
		fn from(value: BitString) -> Self {
			Self::arbitrary(value)
		}
	}
	#[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
	#[rasn(tag(universal, 8))]
	pub struct Myexternal2 {
		#[rasn(identifier = "direct-reference")]
		pub direct_reference: Option<ObjectIdentifier>,
		#[rasn(identifier = "indirect-reference")]
		pub indirect_reference: Option<Integer>,
		pub encoding: Myexternal2Encoding,
	}
	impl Myexternal2 {
		pub fn new(
			direct_reference: Option<ObjectIdentifier>,
			indirect_reference: Option<Integer>,
			encoding: Myexternal2Encoding,
		) -> Self {
			Self { direct_reference, indirect_reference, encoding }
		}
	}
	#[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
	#[rasn(delegate, identifier = "Presentation-context-identifier")]
	pub struct PresentationContextIdentifier(pub Integer);
	#[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
	#[rasn(tag(application, 3), identifier = "RLRE-apdu")]
	pub struct RLREApdu {
		#[rasn(tag(context, 0))]
		pub reason: Option<ReleaseResponseReason>,
		#[rasn(tag(context, 30), identifier = "user-information")]
		pub user_information: Option<AssociationData>,
	}
	impl RLREApdu {
		pub fn new(
			reason: Option<ReleaseResponseReason>,
			user_information: Option<AssociationData>,
		) -> Self {
			Self { reason, user_information }
		}
	}
	#[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
	#[rasn(tag(application, 2), identifier = "RLRQ-apdu")]
	pub struct RLRQApdu {
		#[rasn(tag(context, 0))]
		pub reason: Option<ReleaseRequestReason>,
		#[rasn(tag(context, 30), identifier = "user-information")]
		pub user_information: Option<AssociationData>,
	}
	impl RLRQApdu {
		pub fn new(
			reason: Option<ReleaseRequestReason>,
			user_information: Option<AssociationData>,
		) -> Self {
			Self { reason, user_information }
		}
	}
	#[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
	#[rasn(delegate, identifier = "Release-request-reason")]
	pub struct ReleaseRequestReason(pub Integer);
	#[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
	#[rasn(delegate, identifier = "Release-response-reason")]
	pub struct ReleaseResponseReason(pub Integer);
	#[derive(AsnType, Debug, Clone, Decode, Encode, PartialEq, Eq, Hash)]
	#[rasn(delegate, identifier = "Simply-encoded-data")]
	pub struct SimplyEncodedData(pub OctetString);
	#[doc = "  may be used to reference the abstract syntax of the ACSE APDUs."]
	pub static A_CSE_ID: LazyLock<ObjectIdentifier> =
		LazyLock::new(|| Oid::const_new(&[2u32, 2u32, 3u32, 1u32, 1u32]).to_owned());
	#[doc = " IMPORTS"]
	#[doc = "   Name, RelativeDistinguishedName"]
	#[doc = "     FROM InformationFramework { joint-iso-itu-t ds(5) module(1)"]
	#[doc = "       informationFramework(1) 3 } ;"]
	#[doc = " EXPORTS"]
	#[doc = "   acse-as-id, ACSE-apdu, aCSE-id, ASO-context-name, AP_title,"]
	#[doc = "     AE_qualifier, AE_title, AP_invocation_identifier, AE_invocation_identifier,"]
	#[doc = "     Mechanism_name, Authentication_value, ACSE_requirements, ObjectSet;"]
	#[doc = "  object identifier assignments"]
	pub static ACSE_AS_ID: LazyLock<ObjectIdentifier> =
		LazyLock::new(|| Oid::const_new(&[2u32, 2u32, 1u32, 0u32, 1u32]).to_owned());
}
